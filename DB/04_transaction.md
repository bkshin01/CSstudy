# ✔️ 트랜잭션(Transaction)

## 트랜잭션이 무엇인지 설명해 보세요.
트랜잭션은 데이터베이스 내에서 수행되는 작업의 최소 단위로, 
데이터베이스의 무결성을 유지하며 DB의 상태를 변화시키는 기능을 수행합니다.

<br>

## 트랜잭션 보호가 왜 필요한지 말해보세요.
다수의 사용자가 데이터베이스의 데이터에 접근할 때 데이터의 무결성을 보장하기 위해 트랜잭션을 보호해야 합니다.

<br>

## 트랜잭션의 성질은 어떤게 있어요?
트랜잭션은 ACID라는 네 가지 성질을 가집니다.<br>
`원자성(Atomicty)`는 트랜잭션에 관련된 작업은 원자적으로 실행되거나 실행되지 않아야 한다는 의미입니다.
즉, 모두 다 실행되거나 모두 다 실행되지 않도록 보장되어야 하는 것을 의미합니다.<br>
`일관성(Consistency)`는 트랜잭션이 완료된 시점 전후의 데이터베이스의 상태가 일관되어야 한다는 의미입니다.<br>
`격리성(Isolation)`은 트랜잭션들이 수행될 때 서로 독립적으로 수행되어 간섭할 수 없게 해야 하는 것을 의미합니다.<br>
`지속성(Durability)`는 한 번 성공한 트랜잭션은 데이터베이스에 영구적으로 반영되어야 한다는 것을 의미합니다.

<br>

## 원자성을 보장하는 방법에 대해서 설명해 보세요.
트랜잭션의 원자성을 보장하기 위해 데이터베이스는 `Commit`과 `Rollback`을 사용합니다.<br>
커밋은 트랜잭션의 작업이 정상적으로 종료되었고 데이터베이스에 적용되었음을 확정합니다.
롤백은 현재까지 진행중이던 트랜잭션 작업을 취소하고 트랜잭션이 시작되기 전 상태로 데이터베이스를 되돌립니다.

<br>

## 일관성은 그럼 어떻게 보장할까요?
`Trigger`를 통해 어떤 작업이 수행될 때 연쇄적으로 다른 작업을 수행하도록 할 수 있습니다.
예를 들어 한 테이블의 튜플을 삭제한다고 했을 때, 외래키에 의해 연결된 테이블이 있다면 해당 테이블의 튜플도 함께 삭제해주는 작업을 트리거로 지정할 수 있습니다.

<br>

## 격리성이 보장되지 않아 발생하는 이슈를 설명해 보세요.
첫째, `Phantom Read` 문제가 있습니다. 
한 트랜잭션 내에서 같은 쿼리를 두 번 수행했는데, 
첫 번째 쿼리에서 없던 유령(Phantom) 레코드가 두 번째 쿼리에서 나타나는 현상을 말합니다.<br>

둘째, `Non-Repeatable Read`는 한 트랜잭션 내에서 같은 키를 가진 데이터를 두 번 읽었는데 
그 사이에 값이 변경되거나 삭제되어 결과가 다르게 나타나는 현상을 말합니다.<br>

마지막으로 `Dirty Read`는 다른 트랜잭션에 의해 수정됐지만 아직 커밋되지 않은 데이터를 읽는 것을 말합니다.
어떤 트랜잭션이 아직 Commit을 하지 않은 상황에서 데이터를 수정하고 다른 트랜잭션이 수정된 데이터를 읽었을 때, 
앞선 트랜잭션이 rollback 된다면 데이터베이스에 더 이상 존재하지 않는 데이터를 조회하게 되는 현상을 의미합니다.

<br>

## 트랜잭션 격리 수준에 대해서 설명해 보세요.
Level 0부터 3까지 있습니다.
- Level 0은 `Read Uncommited`로 모든 트랜잭션이 제한없이 데이터에 접근할 수 있게 합니다.
- Level 1은 `Read Commited`로 커밋이 완료된 데이터만 읽도록 합니다.
- Level 2는 `Repeatable Read`로 한 트랜잭션 안에서 여러 번 테이블을 조회해도 같은 데이터를 얻을 수 있도록 합니다.
  이를 위해 해당 트랜잭션이 시작되기 전에 완료된 커밋을 기준으로 데이터를 조회합니다.
- Level 3은 `Serializable`으로 여러 트랜잭션이 병렬적으로 수행되는 것을 허용하지 않는 격리 수준을 말합니다.

<br>

## 공유 lock과 베타 lock에 대해 설명해 보세요.
공유 락은 데이터를 읽을 때 사용하는 락이고, 베타 락은 데이터를 변경할 때 사용하는 락입니다.<br>
공유 락으로 인해 읽기 연산은 여러 트랜잭션이 동시에 실행될 수 있고, 베타 락으로 인해 데이터 변경을 차단합니다.
베타 락이 해제될 때까지 다른 트랜잭션이 데이터를 변경하지 못하게 됩니다.

<br>

## Lock을 사용했을 때 단점은?
과도하게 사용하게 되면 동시성 문제는 해결되지만 처리 시간이 길어진다는 단점이 있습니다.
