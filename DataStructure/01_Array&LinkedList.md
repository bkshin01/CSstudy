# ✔️ 배열(Array) & 링크드 리스트(Linked List)

## 배열은 어떤 자료구조 인가요?
배열은 연관된 데이터를 메모리상에 연속적이며 순차적으로 미리 할당된 크기만큼 저장하는 자료구조입니다.<br>
고정된 저장 공간에 순차적으로 데이터를 저장하는 것이 특징입니다.

<br>

## 배열의 장단점은 어떤가요?
장점은 빠른 lookup과 데이터 추가입니다. 따라서 조회를 자주 해야 하는 작업에는 배열을 많이 사용합니다.<br>
단점은 고정된 사이즈를 미리 선언해야 한다는 것입니다. 이는 메모리 낭비나 추가적인 오버헤드가 발생할 수 있습니다.

<br>

## 배열 연산의 시간복잡도를 설명해 주세요.
|  | Array |
| --- | --- |
| access | O(1) |
| append | O(1) |
| 마지막 원소 delete | O(1) |
| insertion | ❗O(n) |
| deletion | ❗O(n) |
| search | ❗O(n) |

<br>

## 미리 예상한 것보다 더 많은 수의 데이터를 저장하느라 배열의 크기를 넘어서게 되면 어떻게 하나요?
더 큰 배열을 생성하고 데이터를 복사해 넣는 방법이 있습니다. 
이는 메모리를 새로 할당하고 복사하는 오버헤드가 발생하지만, 원하는 만큼 배열의 크기를 확장할 수 있다는 장점이 있습니다.<br>
배열 대신에 LinkedList를 사용하는 방법도 있습니다. 저장해야 할 데이터의 양이 명확하지 않은 경우에는 이 방법이 더 효율적일 수 있습니다.

## Dynamic Array는 어떤 자료구조 인가요?
일반 배열과 다르게 배열의 사이즈 가득 데이터가 저장되면 resize하여 유동적으로 크기를 조절해 데이터를 저장하는 배열입니다.

<br>

## 동적 배열이 resize하는 방법에 대해 설명해 주세요.
대표적으로 기존 배열 크기의 2배를 할당하는 doubling이 있습니다.

<br>

## 동적 배열의 append 시간복잡도에 대해 설명해 보세요.
append의 과정을 살펴보면 순차적으로 데이터를 추가하는 작업이 대다수이고,
크기를 넘어설 때 크기를 두 배 늘리고 데이터를 일일이 옮기는 작업은 아주 가끔 발생합니다.<br>
결론적으로 append의 전체 시간복잡도는 amortized O(1)이라고 부릅니다.
가끔 발생하는 O(n)의 resize하는 시간을 자주 발생하는 O(1)의 작업들이 분담해 나눠 가짐으로써 전체적으로 O(1)에 가깝워 지게 됩니다.

<br>

## Linked List에 대해서 설명해 주세요.
링크드 리스트는 노드라는 구조체로 이루어져 있는데, 하나의 노드는 데이터값과 다음 노드의 주소를 저장합니다.
물리적인 메모리 상에서는 비연속적으로 저장이 되지만, 각각의 노드가 다음 노드의 주소를 가리킴으로써 논리적인 연속성을 가지는 자료구조 입니다.

<br>

## 링크드 리스트의 장단점은 어떤가요?
메모리에서 연속성을 유지하지 않아도 되기 때문에 메모리 사용이 좀 더 자유로운 대신, 
다음 주소를 추가적으로 저장해야 하기 때문에 데이터 하나당 차지하는 메모리가 더 커지게 됩니다.

<br>

## 링크드 리스트 연산의 시간복잡도를 설명해 주세요.
|  | Linked List |
| --- | --- |
| access | ❗O(n) |
| search | ❗O(n) |
| insertion | O(1) |
| deletion | O(1) |

<br>

## 배열과 링크드 리스트를 비교해 설명해 주세요.
두 자료구조는 메모리에 데이터를 저장하는 방식이 달라 연산의 시간복잡도가 다릅니다.<br>
배열은 물리적 메모리 상에서 연속적으로 데이터를 저장하고,
링크드 리스트는 논리적 연속성을 유지합니다.<br>
데이터 조회는 배열의 경우 O(1), 링크드 리스트는 O(n)의 시간 복잡도를 가지는 반면, 
삽입고 삭제는 배열의 경우 O(n), 링크드 리스트는 O(1)의 시간 복잡도를 갖습니다.

<br>

## 배열과 링크드 리스트는 어떤 상황에서 쓰는 게 좋을까요?
얼마만큼의 데이터를 저장할지 미리 알고있고, 조회를 많이 한다면 배열을 사용하는 것이 좋겠습니다.<br>
반면에 몇 개의 데이터를 저장할지 불확실하고 삽입과 삭제가 잦다면 링크드 리스트를 사용하는 것이 유리합니다.

<br>

## 배열과 링크드 리스트 사용 예시를 설명해 보세요.
빠른 인덱스 접근이 필요하거나 데이터의 크기가 고정적인 상황이라면 배열을 사용하는 것이 좋습니다.
예를 들어, 월별 평균 기온 데이터를 저장해야 하는 경우나 프로그램 시작 시에 로드되어 변경되지 않는 설정 값들을 저장하는 경우가 있습니다.<br>
중간 삽입과 삭제가 빈번하고, 데이터의 크기가 유동적이며, 메모리 할당이 중요한 상황이라면 링크드 리스트를 사용하는 것이 유리합니다.
예를 들어, 텍스트 에디터에서 문자를 입력하고 삭제하는 과정이나 
네트워크 패킷의 크기는 일정하지 않으니 네트워크 패킷 처리 시스템에서 쓰일 수 있겠습니다.

<br>

## 배열과 링크드 리스트의 memory allocation은 언제 일어나며, 메모리의 어느 영역을 할당받나요?
배열은 정적 할당과 동적 할당이 있습니다.
정적 할당은 컴파일 시점에 메모리의 크기가 결정되어 프로그램이 실행되는 동안 변하지 않음을 의미하고, 이때는 메모리의 stack 영역에 할당됩니다.
동적 할당은 프로그램의 실행 중에 필요에 따라 메모리를 할당하는 것을 말하며 런타임에 크기를 조절할 수 있습니다. 이때는 메모리의 heap 영역에 할당됩니다.<br>
링크드 리스트는 동적 할당이 이뤄집니다.
링크드 리스트의 각 노드는 프로그램 실행 중에 필요에 따라 개별적으로 메모리를 할당받고, 이때는 메모리의 heap 영역에 할당됩니다.

<br>

## 동적 배열과 링크드 리스트를 비교해 장단점을 설명해 주세요.
동적 배열은 링크드 리스트에 비해 인덱스를 활용한 랜덤 액세스가 빠르다는 장점이 있습니다. 
또한 추가적인 포인터를 저장할 필요가 없기 때문에 메모리 사용이 효율적입니다.<br>
하지만 동적 배열은 선언한 사이즈를 넘어서 데이터를 저장하고자 할 때 새로운 배열을 할당하거나 복사할 필요가 있고,
중간 삽입 및 삭제 속도가 느린 편입니다.
