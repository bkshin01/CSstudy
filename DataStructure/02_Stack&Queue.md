# ✔️ 스택(Stack) & 큐(Queue)

## Stack은 어떤 자료구조 인가요? 언제 사용되나요?
스택은 후입선출의 LIFO 자료구조 입니다. 시간복잡도는 push, pop 모두 O(1)이며
후위 표기법 연산, 괄호 유효성 검사, 웹 브라우저 방문기록, 깊이우선 탐색 등에서 사용됩니다.

<br>

## Queue는 어떤 자료구조 인가요? 언제 사용되나요?
큐는 선입선출의 FIFO 자료구조 입니다. 시간복잡도는 데이터를 추가하는 enqueue에 O(1), 데이터를 추출하는 dequeue에 O(1)입니다.
캐시 구현, 프로세스 관리, 너비우선탐색 등에 사용될 수 있습니다.

<br>

## 스택과 큐의 차이점을 설명해 보세요.
스택은 LIFO 성격의 자료구조로 가장 마지막에 넣은 원소를 가장 먼저 꺼냅니다.
반면에 큐는 FIFO 성격의 자료구조로 먼저 들어간 원소를 가장 먼저 꺼냅니다.

<br>

## 큐를 구현하는 방식에 대해 설명해 보세요.
배열을 기반으로 구현하게 되면 enqueue와 dequeue 과정에서 남는 메모리가 생깁니다. 따라서 원형 큐 형식으로 구현합니다.
리스트 기반으로 구현하게 되면 재할당이나 메모리 낭비의 걱정을 할 필요가 없어집니다.

<br>

## 원형 큐의 시작과 끝 인덱스 관리법에 대해 설명해 보세요.
원형 큐는 front와 rear를 가르키는 포인터를 사용합니다.
삽입할 때는 항상 rear에 값을 넣고, 삭제할 때는 항상 front의 값을 삭제합니다.<br>
만약 두 포인터가 가리키는 인덱스가 같고, 값이 있다면 원형 큐가 가득 찬 것으로 판단합니다.

<br>

## front/rear 인덱스의 값을 비워두는 원형 큐는 왜 그럴까요?
원형 큐는 두 포인터를 기준으로 큐가 포화 상태인지 확인하기 때문입니다.
큐의 상태를 확인하는 과정에선 front와 rear의 값을 비교해야 하는데, 
이때 둘 중 하나를 비워 rear + 1을 front로 비교하는 등의 연산을 수행합니다.

<br>

## 스택 두 개를 이용하여 큐를 구현하고 시간복잡도를 설명해 보세요.
큐의 enqueue()를 구현할 때 첫 번째 스택을 사용하고,
dequeue()를 구현할 때 두 번째 스택을 사용하면 큐를 구현할 수 있습니다.
편의상 전자를 `instack`, 후자를 `outstack`이라고 칭하겠습니다.
```python3
class Queue(object):
  def __init__(self):
      self.instack = []
      self.outstack = []
  
  def enqueue(self, element):
      self.instack.append(element)
  
  def dequeue(self):
      if not self.outstack:
          while self.instack:
              self.outstack.append(self.instack.pop())
      return self.outstack.pop()
```
enqueue() 연산은 데이터를 스택에 추가하는 작업으로 볼 수 있으므로 O(1),
dequeue() 연산은 데이터를 모두 옮기고, 데이터를 하나 추출하는 작업이므로 O(n)이라고 볼 수 있습니다.

<br>

## 큐를 두 개 이용하여 스택을 구현하고 시간복잡도를 설명해 보세요.
편의상 push()를 구현할 때 사용하는 큐를 `q1`이라고 부르고,
pop()을 구현할 때 사용하는 큐를 `q2`라고 하겠습니다.
```python3
from queue import Queue

class Stack(object):
  def __init__(self):
      self.q1 = Queue()
      self.q2 = Queue()
  
  def push(self, element):
      self.q1.put(element)
  
  def pop(self):
      while self.q1.qsize() > 1:
          self.q2.put(self.q1.get())
      
      tmp = self.q1
      self.q1 = self.q2
      self.q2 = tmp
      
      return self.q2.get()
```
push() 연산은 데이터를 추가하는 작업으로 볼 수 있으므로 O(1),
pop() 연산은 데이터를 모두 옮기고 데이터 하나를 추출하는 작업이므로 O(n)이라고 볼 수 있습니다.

<br>

## 큐와 우선순위 큐를 비교하여 설명해 보세요.
큐는 FIFO 구조의 자료구조지만, 우선순위 큐는 데이터가 추가된 순서에 상관없이 우선순위가 높은 데이터가 먼저 추출됩니다.

<br>

## 우선순위 큐를 구현하는 방법은 어떤 게 있을까요?
우선순위 큐는 보통 완전이진트리 구조인 heap을 사용해서 구현됩니다.
힙은 각 노드에 저장된 값이 자식 노드들에 저장된 값보다 작거나 같으면 min heap, 크거나 같으면 max heap이 됩니다.

<br>

## 힙을 구현하는 방법은 어떤 게 있을까요?
트리는 보통 링크드 리스트로 구현합니다. 하지만 힙은 트리임에도 불구하고 배열을 기반으로 구현합니다.
새로운 노드를 마지막 위치에 추가할 때 더 수월하기 때문입니다.<br>

<br>

## 배열을 사용해 힙을 구현하는 방법에 대해 설명해 보세요.
보통 구현의 편의를 위해서 0번째 인덱스는 사용하지 않습니다.
완전이진트리의 특성을 활용해 배열의 인덱스만으로 부모 자식간의 관계를 정의합니다.<br>
- n번째 노드의 왼쪽 자식 노드 = 2n번째
- n번째 노드의 오른쪽 자식 노드 = 2n+1번째
- n번째 노드의 부모 노드 = n/2번째

<br>

## 힙 연산들의 시간복잡도는 어떻게 되나요?
push와 pop 모두 O(log N)의 시간복잡도를 갖습니다.<br>
힙 트리의 높이는 `log N` 이고, push와 pop모두 노드의 위치를 찾아 swap하는 과정이 최대 트리의 높이만큼 발생하기 때문입니다.

<br>

## 힙 말고 다른 방법으로 우선순위 큐를 만들 수 없을까요?
링크드 리스트로도 구현할 수 있습니다. 이때 삽입은 O(n), 삭제는 O(1)의 시간복잡도를 가녀
데이터의 개수가 많아질수록 힙을 사용한 방법에 비해 효율이 떨어집니다.
